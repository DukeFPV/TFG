"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@pinecone-database+doc-splitter@0.0.1";
exports.ids = ["vendor-chunks/@pinecone-database+doc-splitter@0.0.1"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@pinecone-database+doc-splitter@0.0.1/node_modules/@pinecone-database/doc-splitter/dist/index.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@pinecone-database+doc-splitter@0.0.1/node_modules/@pinecone-database/doc-splitter/dist/index.js ***!
  \*****************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MarkdownTextSplitter = exports.RecursiveCharacterTextSplitter = exports.SupportedTextSplitterLanguages = exports.TextSplitter = exports.Document = void 0;\nvar Document = /** @class */ (function () {\n    function Document(fields) {\n        this.pageContent = fields.pageContent || \"\";\n        this.metadata = fields.metadata || {};\n    }\n    return Document;\n}());\nexports.Document = Document;\nvar TextSplitter = /** @class */ (function () {\n    function TextSplitter(fields) {\n        var _a, _b;\n        this.chunkSize = 1000;\n        this.chunkOverlap = 200;\n        this.chunkSize = (_a = fields === null || fields === void 0 ? void 0 : fields.chunkSize) !== null && _a !== void 0 ? _a : this.chunkSize;\n        this.chunkOverlap = (_b = fields === null || fields === void 0 ? void 0 : fields.chunkOverlap) !== null && _b !== void 0 ? _b : this.chunkOverlap;\n        if (this.chunkOverlap >= this.chunkSize) {\n            throw new Error(\"Cannot have chunkOverlap >= chunkSize\");\n        }\n    }\n    TextSplitter.prototype.getNewLinesCount = function (text) {\n        return (text.match(/\\n/g) || []).length;\n    };\n    TextSplitter.prototype.getLoc = function (metadata, from, to) {\n        var loc = metadata.loc && typeof metadata.loc === \"object\"\n            ? __assign({}, metadata.loc) : {};\n        return __assign(__assign({}, metadata), { loc: __assign(__assign({}, loc), { lines: { from: from, to: to } }) });\n    };\n    TextSplitter.prototype.getIntermediateNewLines = function (text, prevChunk, chunk) {\n        if (!prevChunk)\n            return 0;\n        var indexChunk = text.indexOf(chunk);\n        var indexEndPrevChunk = text.indexOf(prevChunk) + prevChunk.length;\n        var removedNewlinesFromSplittingText = text.slice(indexEndPrevChunk, indexChunk);\n        return this.getNewLinesCount(removedNewlinesFromSplittingText);\n    };\n    TextSplitter.prototype.createDocumentsFromText = function (text, metadata) {\n        return __awaiter(this, void 0, void 0, function () {\n            var lineCounterIndex, prevChunk, documents, _i, _a, chunk, intermediateNewLines, newLinesCount, updatedMetadata;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        lineCounterIndex = 1;\n                        prevChunk = null;\n                        documents = [];\n                        _i = 0;\n                        return [4 /*yield*/, this.splitText(text)];\n                    case 1:\n                        _a = _b.sent();\n                        _b.label = 2;\n                    case 2:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        chunk = _a[_i];\n                        intermediateNewLines = this.getIntermediateNewLines(text, prevChunk, chunk);\n                        lineCounterIndex += intermediateNewLines;\n                        newLinesCount = this.getNewLinesCount(chunk);\n                        updatedMetadata = this.getLoc(metadata, lineCounterIndex, lineCounterIndex + newLinesCount);\n                        documents.push(new Document({ pageContent: chunk, metadata: updatedMetadata }));\n                        lineCounterIndex += newLinesCount;\n                        prevChunk = chunk;\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 2];\n                    case 4: return [2 /*return*/, documents];\n                }\n            });\n        });\n    };\n    TextSplitter.prototype.createDocuments = function (texts, metadatas) {\n        if (metadatas === void 0) { metadatas = []; }\n        return __awaiter(this, void 0, void 0, function () {\n            var documentPromises;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        metadatas = metadatas.length > 0 ? metadatas : new Array(texts.length).fill({});\n                        documentPromises = texts.map(function (text, i) { return _this.createDocumentsFromText(text, metadatas[i]); });\n                        return [4 /*yield*/, Promise.all(documentPromises)];\n                    case 1: return [2 /*return*/, (_a.sent()).flat()];\n                }\n            });\n        });\n    };\n    TextSplitter.prototype.splitDocuments = function (documents) {\n        return __awaiter(this, void 0, void 0, function () {\n            var selectedDocuments, texts, metadatas;\n            return __generator(this, function (_a) {\n                selectedDocuments = documents.filter(function (doc) { return doc.pageContent !== undefined; });\n                texts = selectedDocuments.map(function (doc) { return doc.pageContent; });\n                metadatas = selectedDocuments.map(function (doc) { return doc.metadata; });\n                return [2 /*return*/, this.createDocuments(texts, metadatas)];\n            });\n        });\n    };\n    TextSplitter.prototype.joinDocs = function (docs, separator) {\n        var text = docs.join(separator).trim();\n        return text === \"\" ? null : text;\n    };\n    TextSplitter.prototype.warnForExcessChunkSize = function (total) {\n        if (total > this.chunkSize) {\n            console.warn(\"Created a chunk of size \".concat(total, \", which is longer than the specified \").concat(this.chunkSize));\n        }\n    };\n    TextSplitter.prototype.createDocAndAdjustCurrentDoc = function (currentDoc, separator, total, len) {\n        var doc = this.joinDocs(currentDoc, separator);\n        while (total > this.chunkOverlap || (total + len > this.chunkSize && total > 0)) {\n            total -= currentDoc[0].length;\n            currentDoc.shift();\n        }\n        return doc;\n    };\n    TextSplitter.prototype.mergeSplits = function (splits, separator) {\n        var docs = [];\n        var currentDoc = [];\n        var total = 0;\n        for (var _i = 0, splits_1 = splits; _i < splits_1.length; _i++) {\n            var d = splits_1[_i];\n            var len = d.length;\n            if (total + len >= this.chunkSize) {\n                this.warnForExcessChunkSize(total);\n                if (currentDoc.length > 0) {\n                    var doc_1 = this.createDocAndAdjustCurrentDoc(currentDoc, separator, total, len);\n                    if (doc_1 !== null) {\n                        docs.push(doc_1);\n                    }\n                }\n            }\n            currentDoc.push(d);\n            total += len;\n        }\n        var doc = this.joinDocs(currentDoc, separator);\n        if (doc !== null) {\n            docs.push(doc);\n        }\n        return docs;\n    };\n    return TextSplitter;\n}());\nexports.TextSplitter = TextSplitter;\nexports.SupportedTextSplitterLanguages = [\n    \"markdown\",\n    \"latex\",\n    \"html\",\n];\nvar RecursiveCharacterTextSplitter = /** @class */ (function (_super) {\n    __extends(RecursiveCharacterTextSplitter, _super);\n    function RecursiveCharacterTextSplitter(fields) {\n        var _this = this;\n        var _a;\n        _this = _super.call(this, fields) || this;\n        _this.separators = [\"\\n\\n\", \"\\n\", \" \", \"\"];\n        _this.separators = (_a = fields === null || fields === void 0 ? void 0 : fields.separators) !== null && _a !== void 0 ? _a : _this.separators;\n        return _this;\n    }\n    RecursiveCharacterTextSplitter.prototype.splitText = function (text) {\n        return __awaiter(this, void 0, void 0, function () {\n            var finalChunks, separator, _i, _a, s, splits, goodSplits, _b, splits_2, s, mergedText, otherInfo, mergedText;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        finalChunks = [];\n                        separator = this.separators[this.separators.length - 1];\n                        for (_i = 0, _a = this.separators; _i < _a.length; _i++) {\n                            s = _a[_i];\n                            if (s === \"\") {\n                                separator = s;\n                                break;\n                            }\n                            if (text.includes(s)) {\n                                separator = s;\n                                break;\n                            }\n                        }\n                        if (separator) {\n                            splits = text.split(separator);\n                        }\n                        else {\n                            splits = text.split(\"\");\n                        }\n                        goodSplits = [];\n                        _b = 0, splits_2 = splits;\n                        _c.label = 1;\n                    case 1:\n                        if (!(_b < splits_2.length)) return [3 /*break*/, 5];\n                        s = splits_2[_b];\n                        if (!(s.length < this.chunkSize)) return [3 /*break*/, 2];\n                        goodSplits.push(s);\n                        return [3 /*break*/, 4];\n                    case 2:\n                        if (goodSplits.length) {\n                            mergedText = this.mergeSplits(goodSplits, separator);\n                            finalChunks.push.apply(finalChunks, mergedText);\n                            goodSplits = [];\n                        }\n                        return [4 /*yield*/, this.splitText(s)];\n                    case 3:\n                        otherInfo = _c.sent();\n                        finalChunks.push.apply(finalChunks, otherInfo);\n                        _c.label = 4;\n                    case 4:\n                        _b++;\n                        return [3 /*break*/, 1];\n                    case 5:\n                        if (goodSplits.length) {\n                            mergedText = this.mergeSplits(goodSplits, separator);\n                            finalChunks.push.apply(finalChunks, mergedText);\n                        }\n                        return [2 /*return*/, finalChunks];\n                }\n            });\n        });\n    };\n    RecursiveCharacterTextSplitter.prototype.mergeSplits = function (splits, separator) {\n        var mergedText = [];\n        var currentChunk = \"\";\n        for (var _i = 0, splits_3 = splits; _i < splits_3.length; _i++) {\n            var s = splits_3[_i];\n            if (currentChunk.length + s.length < this.chunkSize) {\n                currentChunk += s + separator;\n            }\n            else {\n                mergedText.push(currentChunk.trim());\n                currentChunk = s + separator;\n            }\n        }\n        if (currentChunk) {\n            mergedText.push(currentChunk.trim());\n        }\n        return mergedText;\n    };\n    RecursiveCharacterTextSplitter.getSeparatorsForLanguage = function (language) {\n        if (language === \"markdown\") {\n            return [\n                // First, try to split along Markdown headings (starting with level 2)\n                \"\\n## \",\n                \"\\n### \",\n                \"\\n#### \",\n                \"\\n##### \",\n                \"\\n###### \",\n                // Note the alternative syntax for headings (below) is not handled here\n                // Heading level 2\n                // ---------------\n                // End of code block\n                \"```\\n\\n\",\n                // Horizontal lines\n                \"\\n\\n***\\n\\n\",\n                \"\\n\\n---\\n\\n\",\n                \"\\n\\n___\\n\\n\",\n                // Note that this splitter doesn't handle horizontal lines defined\n                // by *three or more* of ***, ---, or ___, but this is not handled\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"latex\") {\n            return [\n                // First, try to split along Latex sections\n                \"\\n\\\\chapter{\",\n                \"\\n\\\\section{\",\n                \"\\n\\\\subsection{\",\n                \"\\n\\\\subsubsection{\",\n                // Now split by environments\n                \"\\n\\\\begin{enumerate}\",\n                \"\\n\\\\begin{itemize}\",\n                \"\\n\\\\begin{description}\",\n                \"\\n\\\\begin{list}\",\n                \"\\n\\\\begin{quote}\",\n                \"\\n\\\\begin{quotation}\",\n                \"\\n\\\\begin{verse}\",\n                \"\\n\\\\begin{verbatim}\",\n                // Now split by math environments\n                \"\\n\\\\begin{align}\",\n                \"$$\",\n                \"$\",\n                // Now split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"html\") {\n            return [\n                // First, try to split along HTML tags\n                \"<body>\",\n                \"<div>\",\n                \"<p>\",\n                \"<br>\",\n                \"<li>\",\n                \"<h1>\",\n                \"<h2>\",\n                \"<h3>\",\n                \"<h4>\",\n                \"<h5>\",\n                \"<h6>\",\n                \"<span>\",\n                \"<table>\",\n                \"<tr>\",\n                \"<td>\",\n                \"<th>\",\n                \"<ul>\",\n                \"<ol>\",\n                \"<header>\",\n                \"<footer>\",\n                \"<nav>\",\n                // Head\n                \"<head>\",\n                \"<style>\",\n                \"<script>\",\n                \"<meta>\",\n                \"<title>\",\n                // Normal type of lines\n                \" \",\n                \"\",\n            ];\n        }\n        else {\n            throw new Error(\"Language \".concat(language, \" is not supported.\"));\n        }\n    };\n    return RecursiveCharacterTextSplitter;\n}(TextSplitter));\nexports.RecursiveCharacterTextSplitter = RecursiveCharacterTextSplitter;\nvar MarkdownTextSplitter = /** @class */ (function (_super) {\n    __extends(MarkdownTextSplitter, _super);\n    function MarkdownTextSplitter(fields) {\n        return _super.call(this, __assign(__assign({}, fields), { separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"markdown\") })) || this;\n    }\n    return MarkdownTextSplitter;\n}(RecursiveCharacterTextSplitter));\nexports.MarkdownTextSplitter = MarkdownTextSplitter;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBpbmVjb25lLWRhdGFiYXNlK2RvYy1zcGxpdHRlckAwLjAuMS9ub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL2RvYy1zcGxpdHRlci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0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QkFBMkIsU0FBUztBQUNwQztBQUNBLDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxxREFBcUQsYUFBYSxpRkFBaUY7QUFDbko7QUFDQTtBQUNBLENBQUM7QUFDRCw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jYXJsb3MvRGVza3RvcC9URkcvVEZHL25vZGVfbW9kdWxlcy8ucG5wbS9AcGluZWNvbmUtZGF0YWJhc2UrZG9jLXNwbGl0dGVyQDAuMC4xL25vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvZG9jLXNwbGl0dGVyL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFya2Rvd25UZXh0U3BsaXR0ZXIgPSBleHBvcnRzLlJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlciA9IGV4cG9ydHMuU3VwcG9ydGVkVGV4dFNwbGl0dGVyTGFuZ3VhZ2VzID0gZXhwb3J0cy5UZXh0U3BsaXR0ZXIgPSBleHBvcnRzLkRvY3VtZW50ID0gdm9pZCAwO1xudmFyIERvY3VtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvY3VtZW50KGZpZWxkcykge1xuICAgICAgICB0aGlzLnBhZ2VDb250ZW50ID0gZmllbGRzLnBhZ2VDb250ZW50IHx8IFwiXCI7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBmaWVsZHMubWV0YWRhdGEgfHwge307XG4gICAgfVxuICAgIHJldHVybiBEb2N1bWVudDtcbn0oKSk7XG5leHBvcnRzLkRvY3VtZW50ID0gRG9jdW1lbnQ7XG52YXIgVGV4dFNwbGl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHRTcGxpdHRlcihmaWVsZHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5jaHVua1NpemUgPSAxMDAwO1xuICAgICAgICB0aGlzLmNodW5rT3ZlcmxhcCA9IDIwMDtcbiAgICAgICAgdGhpcy5jaHVua1NpemUgPSAoX2EgPSBmaWVsZHMgPT09IG51bGwgfHwgZmllbGRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZHMuY2h1bmtTaXplKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNodW5rU2l6ZTtcbiAgICAgICAgdGhpcy5jaHVua092ZXJsYXAgPSAoX2IgPSBmaWVsZHMgPT09IG51bGwgfHwgZmllbGRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZHMuY2h1bmtPdmVybGFwKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmNodW5rT3ZlcmxhcDtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtPdmVybGFwID49IHRoaXMuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaGF2ZSBjaHVua092ZXJsYXAgPj0gY2h1bmtTaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRleHRTcGxpdHRlci5wcm90b3R5cGUuZ2V0TmV3TGluZXNDb3VudCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiAodGV4dC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgfTtcbiAgICBUZXh0U3BsaXR0ZXIucHJvdG90eXBlLmdldExvYyA9IGZ1bmN0aW9uIChtZXRhZGF0YSwgZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGxvYyA9IG1ldGFkYXRhLmxvYyAmJiB0eXBlb2YgbWV0YWRhdGEubG9jID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICA/IF9fYXNzaWduKHt9LCBtZXRhZGF0YS5sb2MpIDoge307XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbWV0YWRhdGEpLCB7IGxvYzogX19hc3NpZ24oX19hc3NpZ24oe30sIGxvYyksIHsgbGluZXM6IHsgZnJvbTogZnJvbSwgdG86IHRvIH0gfSkgfSk7XG4gICAgfTtcbiAgICBUZXh0U3BsaXR0ZXIucHJvdG90eXBlLmdldEludGVybWVkaWF0ZU5ld0xpbmVzID0gZnVuY3Rpb24gKHRleHQsIHByZXZDaHVuaywgY2h1bmspIHtcbiAgICAgICAgaWYgKCFwcmV2Q2h1bmspXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgdmFyIGluZGV4Q2h1bmsgPSB0ZXh0LmluZGV4T2YoY2h1bmspO1xuICAgICAgICB2YXIgaW5kZXhFbmRQcmV2Q2h1bmsgPSB0ZXh0LmluZGV4T2YocHJldkNodW5rKSArIHByZXZDaHVuay5sZW5ndGg7XG4gICAgICAgIHZhciByZW1vdmVkTmV3bGluZXNGcm9tU3BsaXR0aW5nVGV4dCA9IHRleHQuc2xpY2UoaW5kZXhFbmRQcmV2Q2h1bmssIGluZGV4Q2h1bmspO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROZXdMaW5lc0NvdW50KHJlbW92ZWROZXdsaW5lc0Zyb21TcGxpdHRpbmdUZXh0KTtcbiAgICB9O1xuICAgIFRleHRTcGxpdHRlci5wcm90b3R5cGUuY3JlYXRlRG9jdW1lbnRzRnJvbVRleHQgPSBmdW5jdGlvbiAodGV4dCwgbWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxpbmVDb3VudGVySW5kZXgsIHByZXZDaHVuaywgZG9jdW1lbnRzLCBfaSwgX2EsIGNodW5rLCBpbnRlcm1lZGlhdGVOZXdMaW5lcywgbmV3TGluZXNDb3VudCwgdXBkYXRlZE1ldGFkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUNvdW50ZXJJbmRleCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q2h1bmsgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNwbGl0VGV4dCh0ZXh0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IF9hLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVOZXdMaW5lcyA9IHRoaXMuZ2V0SW50ZXJtZWRpYXRlTmV3TGluZXModGV4dCwgcHJldkNodW5rLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lQ291bnRlckluZGV4ICs9IGludGVybWVkaWF0ZU5ld0xpbmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGluZXNDb3VudCA9IHRoaXMuZ2V0TmV3TGluZXNDb3VudChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkTWV0YWRhdGEgPSB0aGlzLmdldExvYyhtZXRhZGF0YSwgbGluZUNvdW50ZXJJbmRleCwgbGluZUNvdW50ZXJJbmRleCArIG5ld0xpbmVzQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRzLnB1c2gobmV3IERvY3VtZW50KHsgcGFnZUNvbnRlbnQ6IGNodW5rLCBtZXRhZGF0YTogdXBkYXRlZE1ldGFkYXRhIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVDb3VudGVySW5kZXggKz0gbmV3TGluZXNDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZDaHVuayA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRvY3VtZW50c107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGV4dFNwbGl0dGVyLnByb3RvdHlwZS5jcmVhdGVEb2N1bWVudHMgPSBmdW5jdGlvbiAodGV4dHMsIG1ldGFkYXRhcykge1xuICAgICAgICBpZiAobWV0YWRhdGFzID09PSB2b2lkIDApIHsgbWV0YWRhdGFzID0gW107IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRvY3VtZW50UHJvbWlzZXM7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFzID0gbWV0YWRhdGFzLmxlbmd0aCA+IDAgPyBtZXRhZGF0YXMgOiBuZXcgQXJyYXkodGV4dHMubGVuZ3RoKS5maWxsKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50UHJvbWlzZXMgPSB0ZXh0cy5tYXAoZnVuY3Rpb24gKHRleHQsIGkpIHsgcmV0dXJuIF90aGlzLmNyZWF0ZURvY3VtZW50c0Zyb21UZXh0KHRleHQsIG1ldGFkYXRhc1tpXSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoZG9jdW1lbnRQcm9taXNlcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKS5mbGF0KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRleHRTcGxpdHRlci5wcm90b3R5cGUuc3BsaXREb2N1bWVudHMgPSBmdW5jdGlvbiAoZG9jdW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZERvY3VtZW50cywgdGV4dHMsIG1ldGFkYXRhcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZERvY3VtZW50cyA9IGRvY3VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGRvYykgeyByZXR1cm4gZG9jLnBhZ2VDb250ZW50ICE9PSB1bmRlZmluZWQ7IH0pO1xuICAgICAgICAgICAgICAgIHRleHRzID0gc2VsZWN0ZWREb2N1bWVudHMubWFwKGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIGRvYy5wYWdlQ29udGVudDsgfSk7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFzID0gc2VsZWN0ZWREb2N1bWVudHMubWFwKGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIGRvYy5tZXRhZGF0YTsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuY3JlYXRlRG9jdW1lbnRzKHRleHRzLCBtZXRhZGF0YXMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRleHRTcGxpdHRlci5wcm90b3R5cGUuam9pbkRvY3MgPSBmdW5jdGlvbiAoZG9jcywgc2VwYXJhdG9yKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZG9jcy5qb2luKHNlcGFyYXRvcikudHJpbSgpO1xuICAgICAgICByZXR1cm4gdGV4dCA9PT0gXCJcIiA/IG51bGwgOiB0ZXh0O1xuICAgIH07XG4gICAgVGV4dFNwbGl0dGVyLnByb3RvdHlwZS53YXJuRm9yRXhjZXNzQ2h1bmtTaXplID0gZnVuY3Rpb24gKHRvdGFsKSB7XG4gICAgICAgIGlmICh0b3RhbCA+IHRoaXMuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDcmVhdGVkIGEgY2h1bmsgb2Ygc2l6ZSBcIi5jb25jYXQodG90YWwsIFwiLCB3aGljaCBpcyBsb25nZXIgdGhhbiB0aGUgc3BlY2lmaWVkIFwiKS5jb25jYXQodGhpcy5jaHVua1NpemUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dFNwbGl0dGVyLnByb3RvdHlwZS5jcmVhdGVEb2NBbmRBZGp1c3RDdXJyZW50RG9jID0gZnVuY3Rpb24gKGN1cnJlbnREb2MsIHNlcGFyYXRvciwgdG90YWwsIGxlbikge1xuICAgICAgICB2YXIgZG9jID0gdGhpcy5qb2luRG9jcyhjdXJyZW50RG9jLCBzZXBhcmF0b3IpO1xuICAgICAgICB3aGlsZSAodG90YWwgPiB0aGlzLmNodW5rT3ZlcmxhcCB8fCAodG90YWwgKyBsZW4gPiB0aGlzLmNodW5rU2l6ZSAmJiB0b3RhbCA+IDApKSB7XG4gICAgICAgICAgICB0b3RhbCAtPSBjdXJyZW50RG9jWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGN1cnJlbnREb2Muc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jO1xuICAgIH07XG4gICAgVGV4dFNwbGl0dGVyLnByb3RvdHlwZS5tZXJnZVNwbGl0cyA9IGZ1bmN0aW9uIChzcGxpdHMsIHNlcGFyYXRvcikge1xuICAgICAgICB2YXIgZG9jcyA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudERvYyA9IFtdO1xuICAgICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNwbGl0c18xID0gc3BsaXRzOyBfaSA8IHNwbGl0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGQgPSBzcGxpdHNfMVtfaV07XG4gICAgICAgICAgICB2YXIgbGVuID0gZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG90YWwgKyBsZW4gPj0gdGhpcy5jaHVua1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhcm5Gb3JFeGNlc3NDaHVua1NpemUodG90YWwpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RG9jLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvY18xID0gdGhpcy5jcmVhdGVEb2NBbmRBZGp1c3RDdXJyZW50RG9jKGN1cnJlbnREb2MsIHNlcGFyYXRvciwgdG90YWwsIGxlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2NfMSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jcy5wdXNoKGRvY18xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnREb2MucHVzaChkKTtcbiAgICAgICAgICAgIHRvdGFsICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG9jID0gdGhpcy5qb2luRG9jcyhjdXJyZW50RG9jLCBzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoZG9jICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkb2NzLnB1c2goZG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jcztcbiAgICB9O1xuICAgIHJldHVybiBUZXh0U3BsaXR0ZXI7XG59KCkpO1xuZXhwb3J0cy5UZXh0U3BsaXR0ZXIgPSBUZXh0U3BsaXR0ZXI7XG5leHBvcnRzLlN1cHBvcnRlZFRleHRTcGxpdHRlckxhbmd1YWdlcyA9IFtcbiAgICBcIm1hcmtkb3duXCIsXG4gICAgXCJsYXRleFwiLFxuICAgIFwiaHRtbFwiLFxuXTtcbnZhciBSZWN1cnNpdmVDaGFyYWN0ZXJUZXh0U3BsaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWN1cnNpdmVDaGFyYWN0ZXJUZXh0U3BsaXR0ZXIoZmllbGRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmaWVsZHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNlcGFyYXRvcnMgPSBbXCJcXG5cXG5cIiwgXCJcXG5cIiwgXCIgXCIsIFwiXCJdO1xuICAgICAgICBfdGhpcy5zZXBhcmF0b3JzID0gKF9hID0gZmllbGRzID09PSBudWxsIHx8IGZpZWxkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGRzLnNlcGFyYXRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IF90aGlzLnNlcGFyYXRvcnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVjdXJzaXZlQ2hhcmFjdGVyVGV4dFNwbGl0dGVyLnByb3RvdHlwZS5zcGxpdFRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmluYWxDaHVua3MsIHNlcGFyYXRvciwgX2ksIF9hLCBzLCBzcGxpdHMsIGdvb2RTcGxpdHMsIF9iLCBzcGxpdHNfMiwgcywgbWVyZ2VkVGV4dCwgb3RoZXJJbmZvLCBtZXJnZWRUZXh0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxDaHVua3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvciA9IHRoaXMuc2VwYXJhdG9yc1t0aGlzLnNlcGFyYXRvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgX2EgPSB0aGlzLnNlcGFyYXRvcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IgPSBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMocykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0cyA9IHRleHQuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0cyA9IHRleHQuc3BsaXQoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBnb29kU3BsaXRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IDAsIHNwbGl0c18yID0gc3BsaXRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfYiA8IHNwbGl0c18yLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHNwbGl0c18yW19iXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHMubGVuZ3RoIDwgdGhpcy5jaHVua1NpemUpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvb2RTcGxpdHMucHVzaChzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ29vZFNwbGl0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRUZXh0ID0gdGhpcy5tZXJnZVNwbGl0cyhnb29kU3BsaXRzLCBzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmtzLnB1c2guYXBwbHkoZmluYWxDaHVua3MsIG1lcmdlZFRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvb2RTcGxpdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc3BsaXRUZXh0KHMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJJbmZvID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxDaHVua3MucHVzaC5hcHBseShmaW5hbENodW5rcywgb3RoZXJJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ29vZFNwbGl0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRUZXh0ID0gdGhpcy5tZXJnZVNwbGl0cyhnb29kU3BsaXRzLCBzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmtzLnB1c2guYXBwbHkoZmluYWxDaHVua3MsIG1lcmdlZFRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZpbmFsQ2h1bmtzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVDaGFyYWN0ZXJUZXh0U3BsaXR0ZXIucHJvdG90eXBlLm1lcmdlU3BsaXRzID0gZnVuY3Rpb24gKHNwbGl0cywgc2VwYXJhdG9yKSB7XG4gICAgICAgIHZhciBtZXJnZWRUZXh0ID0gW107XG4gICAgICAgIHZhciBjdXJyZW50Q2h1bmsgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNwbGl0c18zID0gc3BsaXRzOyBfaSA8IHNwbGl0c18zLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHMgPSBzcGxpdHNfM1tfaV07XG4gICAgICAgICAgICBpZiAoY3VycmVudENodW5rLmxlbmd0aCArIHMubGVuZ3RoIDwgdGhpcy5jaHVua1NpemUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmsgKz0gcyArIHNlcGFyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlZFRleHQucHVzaChjdXJyZW50Q2h1bmsudHJpbSgpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmsgPSBzICsgc2VwYXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Q2h1bmspIHtcbiAgICAgICAgICAgIG1lcmdlZFRleHQucHVzaChjdXJyZW50Q2h1bmsudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VkVGV4dDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlci5nZXRTZXBhcmF0b3JzRm9yTGFuZ3VhZ2UgPSBmdW5jdGlvbiAobGFuZ3VhZ2UpIHtcbiAgICAgICAgaWYgKGxhbmd1YWdlID09PSBcIm1hcmtkb3duXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLy8gRmlyc3QsIHRyeSB0byBzcGxpdCBhbG9uZyBNYXJrZG93biBoZWFkaW5ncyAoc3RhcnRpbmcgd2l0aCBsZXZlbCAyKVxuICAgICAgICAgICAgICAgIFwiXFxuIyMgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG4jIyMgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG4jIyMjIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuIyMjIyMgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG4jIyMjIyMgXCIsXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGUgYWx0ZXJuYXRpdmUgc3ludGF4IGZvciBoZWFkaW5ncyAoYmVsb3cpIGlzIG5vdCBoYW5kbGVkIGhlcmVcbiAgICAgICAgICAgICAgICAvLyBIZWFkaW5nIGxldmVsIDJcbiAgICAgICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgICAgICAvLyBFbmQgb2YgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgIFwiYGBgXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBsaW5lc1xuICAgICAgICAgICAgICAgIFwiXFxuXFxuKioqXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cXG4tLS1cXG5cXG5cIixcbiAgICAgICAgICAgICAgICBcIlxcblxcbl9fX1xcblxcblwiLFxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIHNwbGl0dGVyIGRvZXNuJ3QgaGFuZGxlIGhvcml6b250YWwgbGluZXMgZGVmaW5lZFxuICAgICAgICAgICAgICAgIC8vIGJ5ICp0aHJlZSBvciBtb3JlKiBvZiAqKiosIC0tLSwgb3IgX19fLCBidXQgdGhpcyBpcyBub3QgaGFuZGxlZFxuICAgICAgICAgICAgICAgIFwiXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5ndWFnZSA9PT0gXCJsYXRleFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC8vIEZpcnN0LCB0cnkgdG8gc3BsaXQgYWxvbmcgTGF0ZXggc2VjdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcblxcXFxjaGFwdGVye1wiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxcXHNlY3Rpb257XCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cXFxcc3Vic2VjdGlvbntcIixcbiAgICAgICAgICAgICAgICBcIlxcblxcXFxzdWJzdWJzZWN0aW9ue1wiLFxuICAgICAgICAgICAgICAgIC8vIE5vdyBzcGxpdCBieSBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgICAgICBcIlxcblxcXFxiZWdpbntlbnVtZXJhdGV9XCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cXFxcYmVnaW57aXRlbWl6ZX1cIixcbiAgICAgICAgICAgICAgICBcIlxcblxcXFxiZWdpbntkZXNjcmlwdGlvbn1cIixcbiAgICAgICAgICAgICAgICBcIlxcblxcXFxiZWdpbntsaXN0fVwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxcXGJlZ2lue3F1b3RlfVwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxcXGJlZ2lue3F1b3RhdGlvbn1cIixcbiAgICAgICAgICAgICAgICBcIlxcblxcXFxiZWdpbnt2ZXJzZX1cIixcbiAgICAgICAgICAgICAgICBcIlxcblxcXFxiZWdpbnt2ZXJiYXRpbX1cIixcbiAgICAgICAgICAgICAgICAvLyBOb3cgc3BsaXQgYnkgbWF0aCBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgICAgICBcIlxcblxcXFxiZWdpbnthbGlnbn1cIixcbiAgICAgICAgICAgICAgICBcIiQkXCIsXG4gICAgICAgICAgICAgICAgXCIkXCIsXG4gICAgICAgICAgICAgICAgLy8gTm93IHNwbGl0IGJ5IHRoZSBub3JtYWwgdHlwZSBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIFwiXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5ndWFnZSA9PT0gXCJodG1sXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLy8gRmlyc3QsIHRyeSB0byBzcGxpdCBhbG9uZyBIVE1MIHRhZ3NcbiAgICAgICAgICAgICAgICBcIjxib2R5PlwiLFxuICAgICAgICAgICAgICAgIFwiPGRpdj5cIixcbiAgICAgICAgICAgICAgICBcIjxwPlwiLFxuICAgICAgICAgICAgICAgIFwiPGJyPlwiLFxuICAgICAgICAgICAgICAgIFwiPGxpPlwiLFxuICAgICAgICAgICAgICAgIFwiPGgxPlwiLFxuICAgICAgICAgICAgICAgIFwiPGgyPlwiLFxuICAgICAgICAgICAgICAgIFwiPGgzPlwiLFxuICAgICAgICAgICAgICAgIFwiPGg0PlwiLFxuICAgICAgICAgICAgICAgIFwiPGg1PlwiLFxuICAgICAgICAgICAgICAgIFwiPGg2PlwiLFxuICAgICAgICAgICAgICAgIFwiPHNwYW4+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGFibGU+XCIsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGg+XCIsXG4gICAgICAgICAgICAgICAgXCI8dWw+XCIsXG4gICAgICAgICAgICAgICAgXCI8b2w+XCIsXG4gICAgICAgICAgICAgICAgXCI8aGVhZGVyPlwiLFxuICAgICAgICAgICAgICAgIFwiPGZvb3Rlcj5cIixcbiAgICAgICAgICAgICAgICBcIjxuYXY+XCIsXG4gICAgICAgICAgICAgICAgLy8gSGVhZFxuICAgICAgICAgICAgICAgIFwiPGhlYWQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8c3R5bGU+XCIsXG4gICAgICAgICAgICAgICAgXCI8c2NyaXB0PlwiLFxuICAgICAgICAgICAgICAgIFwiPG1ldGE+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGl0bGU+XCIsXG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsIHR5cGUgb2YgbGluZXNcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxhbmd1YWdlIFwiLmNvbmNhdChsYW5ndWFnZSwgXCIgaXMgbm90IHN1cHBvcnRlZC5cIikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVjdXJzaXZlQ2hhcmFjdGVyVGV4dFNwbGl0dGVyO1xufShUZXh0U3BsaXR0ZXIpKTtcbmV4cG9ydHMuUmVjdXJzaXZlQ2hhcmFjdGVyVGV4dFNwbGl0dGVyID0gUmVjdXJzaXZlQ2hhcmFjdGVyVGV4dFNwbGl0dGVyO1xudmFyIE1hcmtkb3duVGV4dFNwbGl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXJrZG93blRleHRTcGxpdHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXJrZG93blRleHRTcGxpdHRlcihmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBmaWVsZHMpLCB7IHNlcGFyYXRvcnM6IFJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlci5nZXRTZXBhcmF0b3JzRm9yTGFuZ3VhZ2UoXCJtYXJrZG93blwiKSB9KSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1hcmtkb3duVGV4dFNwbGl0dGVyO1xufShSZWN1cnNpdmVDaGFyYWN0ZXJUZXh0U3BsaXR0ZXIpKTtcbmV4cG9ydHMuTWFya2Rvd25UZXh0U3BsaXR0ZXIgPSBNYXJrZG93blRleHRTcGxpdHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@pinecone-database+doc-splitter@0.0.1/node_modules/@pinecone-database/doc-splitter/dist/index.js\n");

/***/ })

};
;